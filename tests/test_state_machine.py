#!/usr/bin/env python3
"""
Test Nova State Machine
Tests the complete state machine logic for Home Starter Mode
"""

import os
import sys
import time
import logging
import json
import threading
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Add the parent directory to the Python path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class NovaStateMachine:
    """Nova State Machine for Home Starter Mode"""
    
    # State definitions
    STATES = {
        "STARTUP": "System starting up",
        "GREETING_ONCE": "Running one-time greeting sequence",
        "BACKGROUND_IDLE": "Silent background mode, wake word only",
        "WAKE_WORD_DETECTED": "Wake word heard, transitioning to active",
        "ACTIVE_REQUEST": "Processing user request",
        "SPEAKING": "Speaking response to user",
        "RECOVER": "Error recovery mode"
    }
    
    # Valid transitions
    VALID_TRANSITIONS = {
        "STARTUP": ["GREETING_ONCE", "RECOVER"],
        "GREETING_ONCE": ["BACKGROUND_IDLE", "RECOVER"],
        "BACKGROUND_IDLE": ["WAKE_WORD_DETECTED", "RECOVER"],
        "WAKE_WORD_DETECTED": ["ACTIVE_REQUEST", "RECOVER"],
        "ACTIVE_REQUEST": ["SPEAKING", "RECOVER"],
        "SPEAKING": ["BACKGROUND_IDLE", "RECOVER"],
        "RECOVER": ["BACKGROUND_IDLE", "STARTUP"]
    }
    
    def __init__(self):
        self.current_state = "STARTUP"
        self.previous_state = None
        self.state_history = []
        self.transition_count = 0
        self.last_transition_time = None
        self.greeting_completed = False
        self.greeting_timestamp = None
        self.lockfile_path = "/tmp/nova_greeting.lock"
        self.error_count = 0
        self.max_errors = 3
        
        # Initialize state (don't record initial state as a transition)
        self.state_history.append({
            "timestamp": time.time(),
            "from": None,
            "to": "STARTUP",
            "reason": "System initialization",
            "transition_number": 0
        })
    
    def _record_state_change(self, new_state: str, reason: str):
        """Record a state change with metadata"""
        timestamp = time.time()
        
        # Validate transition
        if not self._is_valid_transition(new_state):
            raise ValueError(f"Invalid transition: {self.current_state} ‚Üí {new_state}")
        
        # Record the change
        self.previous_state = self.current_state
        self.current_state = new_state
        self.transition_count += 1
        self.last_transition_time = timestamp
        
        state_record = {
            "timestamp": timestamp,
            "from": self.previous_state,
            "to": new_state,
            "reason": reason,
            "transition_number": self.transition_count
        }
        
        self.state_history.append(state_record)
        
        print(f"üîÑ State Transition: {self.previous_state} ‚Üí {new_state} ({reason})")
        print(f"   üìä Transition #{self.transition_count} at {datetime.fromtimestamp(timestamp)}")
    
    def _is_valid_transition(self, new_state: str) -> bool:
        """Check if a state transition is valid"""
        if self.current_state not in self.VALID_TRANSITIONS:
            return False
        
        return new_state in self.VALID_TRANSITIONS[self.current_state]
    
    def transition_to(self, new_state: str, reason: str = "No reason specified"):
        """Transition to a new state"""
        try:
            self._record_state_change(new_state, reason)
            return True
        except ValueError as e:
            print(f"‚ùå State transition failed: {e}")
            self.error_count += 1
            return False
    
    def get_current_state_info(self) -> Dict[str, Any]:
        """Get detailed information about current state"""
        return {
            "current_state": self.current_state,
            "state_description": self.STATES.get(self.current_state, "Unknown"),
            "previous_state": self.previous_state,
            "transition_count": self.transition_count,
            "last_transition_time": self.last_transition_time,
            "greeting_completed": self.greeting_completed,
            "error_count": self.error_count,
            "state_history_length": len(self.state_history)
        }
    
    def check_greeting_lockfile(self) -> bool:
        """Check if greeting has already been completed this session"""
        try:
            if os.path.exists(self.lockfile_path):
                # Check if lockfile is from today
                stat = os.stat(self.lockfile_path)
                lock_time = datetime.fromtimestamp(stat.st_mtime)
                current_time = datetime.now()
                
                # Check if lockfile is from current session (within last 30 minutes)
                # This allows for fresh greeting on each login while preventing spam
                time_diff = current_time - lock_time
                if time_diff.total_seconds() < 1800:  # 30 minutes
                    print(f"üîí Greeting already completed this session at {lock_time}")
                    return True
                else:
                    print(f"üîÑ Lockfile is from {lock_time}, removing old lock for fresh greeting")
                    os.remove(self.lockfile_path)
                    return False
            return False
        except Exception as e:
            print(f"‚ö†Ô∏è Error checking lockfile: {e}")
            return False
    
    def create_greeting_lockfile(self):
        """Create lockfile to mark greeting as completed"""
        try:
            with open(self.lockfile_path, 'w') as f:
                f.write(f"Nova greeting completed at {datetime.now()}\n")
            self.greeting_completed = True
            self.greeting_timestamp = time.time()
            print(f"üîí Greeting lockfile created at {datetime.now()}")
        except Exception as e:
            print(f"‚ùå Failed to create lockfile: {e}")
    
    def run_startup_sequence(self) -> bool:
        """Run the startup sequence"""
        print("\nüöÄ Running Startup Sequence...")
        
        # Check if we should run greeting
        if self.check_greeting_lockfile():
            print("   ‚úÖ Greeting already completed for this session, skipping to background")
            # Must go through GREETING_ONCE first, then immediately to BACKGROUND_IDLE
            if self.transition_to("GREETING_ONCE", "Greeting already completed"):
                return self.transition_to("BACKGROUND_IDLE", "Greeting already completed")
            return False
        
        # Run greeting sequence
        print("   üéØ Greeting not completed for this session, running greeting sequence")
        return self.transition_to("GREETING_ONCE", "Starting greeting sequence")
    
    def run_greeting_sequence(self) -> bool:
        """Run the one-time greeting sequence"""
        print("\nüéâ Running Greeting Sequence...")
        
        try:
            # Simulate greeting steps
            steps = [
                "Welcome home message",
                "Set private mode (Do Not Disturb)",
                "Start Spotify Nightmode playlist",
                "Read calendar schedule",
                "Productive day message"
            ]
            
            for i, step in enumerate(steps, 1):
                print(f"   {i}. {step}")
                time.sleep(0.5)  # Simulate step execution
            
            # Mark greeting as completed
            self.create_greeting_lockfile()
            
            print("   ‚úÖ Greeting sequence completed successfully")
            return self.transition_to("BACKGROUND_IDLE", "Greeting sequence completed")
            
        except Exception as e:
            print(f"   ‚ùå Greeting sequence failed: {e}")
            return self.transition_to("RECOVER", f"Greeting sequence error: {e}")
    
    def handle_wake_word(self) -> bool:
        """Handle wake word detection"""
        print("\nüëÇ Wake Word Detected...")
        
        if self.current_state != "BACKGROUND_IDLE":
            print(f"   ‚ö†Ô∏è Unexpected wake word in state: {self.current_state}")
            return False
        
        return self.transition_to("WAKE_WORD_DETECTED", "Wake word detected")
    
    def begin_request_processing(self) -> bool:
        """Begin processing user request"""
        print("\nüéØ Beginning Request Processing...")
        
        if self.current_state != "WAKE_WORD_DETECTED":
            print(f"   ‚ö†Ô∏è Cannot begin request processing in state: {self.current_state}")
            return False
        
        return self.transition_to("ACTIVE_REQUEST", "Starting request processing")
    
    def begin_speaking(self) -> bool:
        """Begin speaking response"""
        print("\nüó£Ô∏è Beginning Response...")
        
        if self.current_state != "ACTIVE_REQUEST":
            print(f"   ‚ö†Ô∏è Cannot begin speaking in state: {self.current_state}")
            return False
        
        return self.transition_to("SPEAKING", "Starting response")
    
    def finish_request(self) -> bool:
        """Finish request and return to background"""
        print("\n‚úÖ Finishing Request...")
        
        if self.current_state != "SPEAKING":
            print(f"   ‚ö†Ô∏è Cannot finish request in state: {self.current_state}")
            return False
        
        return self.transition_to("BACKGROUND_IDLE", "Request completed, returning to background")
    
    def handle_error(self, error: str) -> bool:
        """Handle errors and transition to recovery"""
        print(f"\n‚ùå Error occurred: {error}")
        
        self.error_count += 1
        print(f"   ‚ö†Ô∏è Error count: {self.error_count}/{self.max_errors}")
        
        if self.error_count >= self.max_errors:
            print(f"   üö® Max errors reached ({self.max_errors}), transitioning to recovery")
            return self.transition_to("RECOVER", f"Max errors reached: {error}")
        else:
            return False
    
    def recover_from_error(self) -> bool:
        """Attempt to recover from error state"""
        print("\nüîß Attempting Recovery...")
        
        if self.current_state != "RECOVER":
            print(f"   ‚ö†Ô∏è Not in recovery state: {self.current_state}")
            return False
        
        try:
            # Reset error count
            self.error_count = 0
            
            # Try to return to background
            print("   üîÑ Attempting to return to background mode")
            return self.transition_to("BACKGROUND_IDLE", "Recovery successful")
            
        except Exception as e:
            print(f"   ‚ùå Recovery failed: {e}")
            return False
    
    def get_state_summary(self) -> Dict[str, Any]:
        """Get a summary of the state machine"""
        return {
            "current_state": self.current_state,
            "total_transitions": self.transition_count,
            "greeting_completed": self.greeting_completed,
            "error_count": self.error_count,
            "state_history": self.state_history[-5:],  # Last 5 transitions
            "uptime": time.time() - (self.state_history[0]["timestamp"] if self.state_history else time.time())
        }

def test_state_machine_basic():
    """Test basic state machine functionality"""
    print("\nüß™ Testing Basic State Machine Functionality")
    print("=" * 60)
    
    sm = NovaStateMachine()
    
    # Test 1: Initial State
    print("\n1Ô∏è‚É£ Testing Initial State...")
    info = sm.get_current_state_info()
    print(f"   üìä Current state: {info['current_state']}")
    print(f"   üìù Description: {info['state_description']}")
    print(f"   üî¢ Transition count: {info['transition_count']}")
    
    if info['current_state'] == "STARTUP":
        print("   ‚úÖ Initial state correct")
    else:
        print("   ‚ùå Initial state incorrect")
        return False
    
    # Test 2: Valid Transitions
    print("\n2Ô∏è‚É£ Testing Valid Transitions...")
    
    transitions = [
        ("GREETING_ONCE", "Starting greeting sequence"),
        ("BACKGROUND_IDLE", "Greeting completed"),
        ("WAKE_WORD_DETECTED", "Wake word heard"),
        ("ACTIVE_REQUEST", "Processing request"),
        ("SPEAKING", "Speaking response"),
        ("BACKGROUND_IDLE", "Request completed")
    ]
    
    for new_state, reason in transitions:
        success = sm.transition_to(new_state, reason)
        if success:
            print(f"   ‚úÖ {new_state}: {reason}")
        else:
            print(f"   ‚ùå {new_state}: {reason}")
            return False
    
    # Test 3: State History
    print("\n3Ô∏è‚É£ Testing State History...")
    history = sm.state_history
    print(f"   üìä Total transitions: {len(history)}")
    print(f"   üïê First transition: {datetime.fromtimestamp(history[0]['timestamp'])}")
    print(f"   üïê Last transition: {datetime.fromtimestamp(history[-1]['timestamp'])}")
    
    if len(history) == len(transitions) + 1:  # +1 for initial state
        print("   ‚úÖ State history correct")
    else:
        print("   ‚ùå State history incorrect")
        return False
    
    print("\n‚úÖ Basic state machine tests PASSED")
    return True

def test_state_machine_flow():
    """Test complete state machine flow"""
    print("\nüß™ Testing Complete State Machine Flow")
    print("=" * 60)
    
    sm = NovaStateMachine()
    
    # Test 1: Startup Sequence
    print("\n1Ô∏è‚É£ Testing Startup Sequence...")
    
    # Simulate startup
    startup_success = sm.run_startup_sequence()
    if not startup_success:
        print("   ‚ùå Startup sequence failed")
        return False
    
    print("   ‚úÖ Startup sequence successful")
    
    # Test 2: Greeting Sequence
    print("\n2Ô∏è‚É£ Testing Greeting Sequence...")
    
    if sm.current_state == "GREETING_ONCE":
        greeting_success = sm.run_greeting_sequence()
        if not greeting_success:
            print("   ‚ùå Greeting sequence failed")
            return False
        print("   ‚úÖ Greeting sequence successful")
    else:
        print("   ‚ö†Ô∏è Skipped greeting (already completed)")
    
    # Test 3: Background Mode
    print("\n3Ô∏è‚É£ Testing Background Mode...")
    
    if sm.current_state != "BACKGROUND_IDLE":
        print(f"   ‚ùå Not in background mode: {sm.current_state}")
        return False
    
    print("   ‚úÖ Background mode active")
    
    # Test 4: Wake Word Flow
    print("\n4Ô∏è‚É£ Testing Wake Word Flow...")
    
    # Simulate wake word
    wake_success = sm.handle_wake_word()
    if not wake_success:
        print("   ‚ùå Wake word handling failed")
        return False
    
    # Begin request processing
    request_success = sm.begin_request_processing()
    if not request_success:
        print("   ‚ùå Request processing failed")
        return False
    
    # Begin speaking
    speak_success = sm.begin_speaking()
    if not speak_success:
        print("   ‚ùå Speaking failed")
        return False
    
    # Finish request
    finish_success = sm.finish_request()
    if not finish_success:
        print("   ‚ùå Request finishing failed")
        return False
    
    print("   ‚úÖ Complete wake word flow successful")
    
    # Test 5: Return to Background
    print("\n5Ô∏è‚É£ Testing Return to Background...")
    
    if sm.current_state == "BACKGROUND_IDLE":
        print("   ‚úÖ Successfully returned to background mode")
    else:
        print(f"   ‚ùå Failed to return to background: {sm.current_state}")
        return False
    
    print("\n‚úÖ Complete state machine flow tests PASSED")
    return True

def test_state_machine_error_handling():
    """Test state machine error handling"""
    print("\nüß™ Testing State Machine Error Handling")
    print("=" * 60)
    
    # Test 1: Invalid Transitions
    print("\n1Ô∏è‚É£ Testing Invalid Transitions...")
    
    # Create a fresh state machine for invalid transition testing
    sm1 = NovaStateMachine()
    
    # Try invalid transition from STARTUP
    try:
        invalid_success = sm1.transition_to("SPEAKING", "Invalid transition")
        if not invalid_success:
            print("   ‚úÖ Invalid transition properly rejected")
        else:
            print("   ‚ùå Invalid transition should have been rejected")
            return False
    except ValueError as e:
        print(f"   ‚úÖ Invalid transition properly caught: {e}")
    
    # Test 2: Error Handling
    print("\n2Ô∏è‚É£ Testing Error Handling...")
    
    # Create a completely fresh state machine for error testing
    sm2 = NovaStateMachine()
    sm2.error_count = 0  # Ensure clean error count
    
    # Simulate errors
    for i in range(3):
        error_msg = f"Test error {i+1}"
        error_success = sm2.handle_error(error_msg)
        print(f"   ‚ö†Ô∏è Error {i+1}: {error_msg}")
        
        if i < 2:  # First two errors should not trigger recovery
            if error_success:
                print("   ‚ùå Error should not have triggered recovery")
                return False
        else:  # Third error should trigger recovery
            if not error_success:
                print("   ‚ùå Error should have triggered recovery")
                return False
    
    # Test 3: Recovery
    print("\n3Ô∏è‚É£ Testing Recovery...")
    
    if sm2.current_state == "RECOVER":
        print("   ‚úÖ Successfully entered recovery state")
        
        recovery_success = sm2.recover_from_error()
        if recovery_success:
            print("   ‚úÖ Recovery successful")
        else:
            print("   ‚ùå Recovery failed")
            return False
    else:
        print(f"   ‚ùå Not in recovery state: {sm2.current_state}")
        return False
    
    print("\n‚úÖ Error handling tests PASSED")
    return True

def test_state_machine_lockfile():
    """Test lockfile functionality"""
    print("\nüß™ Testing Lockfile Functionality")
    print("=" * 60)
    
    # Clean up any existing lockfile first
    lockfile_path = "/tmp/nova_greeting.lock"
    if os.path.exists(lockfile_path):
        try:
            os.remove(lockfile_path)
            print("   üßπ Cleaned up existing lockfile")
        except Exception as e:
            print(f"   ‚ö†Ô∏è Warning: Could not clean up existing lockfile: {e}")
    
    sm = NovaStateMachine()
    
    # Test 1: No Lockfile
    print("\n1Ô∏è‚É£ Testing No Lockfile...")
    
    has_lock = sm.check_greeting_lockfile()
    if not has_lock:
        print("   ‚úÖ No lockfile detected (expected)")
    else:
        print("   ‚ùå Lockfile detected when none should exist")
        return False
    
    # Test 2: Create Lockfile
    print("\n2Ô∏è‚É£ Testing Lockfile Creation...")
    
    sm.create_greeting_lockfile()
    
    # Check if lockfile was created
    if os.path.exists(sm.lockfile_path):
        print("   ‚úÖ Lockfile created successfully")
    else:
        print("   ‚ùå Lockfile not created")
        return False
    
    # Test 3: Check Lockfile
    print("\n3Ô∏è‚É£ Testing Lockfile Detection...")
    
    has_lock = sm.check_greeting_lockfile()
    if has_lock:
        print("   ‚úÖ Lockfile detected (expected)")
    else:
        print("   ‚ùå Lockfile not detected")
        return False
    
    # Test 4: Cleanup
    print("\n4Ô∏è‚É£ Testing Lockfile Cleanup...")
    
    try:
        os.remove(sm.lockfile_path)
        print("   ‚úÖ Lockfile cleaned up")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Lockfile cleanup warning: {e}")
    
    print("\n‚úÖ Lockfile tests PASSED")
    return True

def main():
    """Run all state machine tests"""
    print("üß™ Starting Nova State Machine Comprehensive Tests")
    print("=" * 60)
    
    tests = [
        ("Basic Functionality", test_state_machine_basic),
        ("Complete Flow", test_state_machine_flow),
        ("Error Handling", test_state_machine_error_handling),
        ("Lockfile Functionality", test_state_machine_lockfile)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        print(f"\n{'='*20} {test_name} {'='*20}")
        
        try:
            success = test_func()
            results.append((test_name, success))
            
            if success:
                print(f"‚úÖ {test_name}: PASSED")
            else:
                print(f"‚ùå {test_name}: FAILED")
                
        except Exception as e:
            print(f"‚ùå {test_name}: ERROR - {e}")
            results.append((test_name, False))
    
    # Summary
    print("\n" + "=" * 60)
    print("üéØ STATE MACHINE TEST RESULTS")
    print("=" * 60)
    
    passed = sum(1 for _, success in results if success)
    total = len(results)
    
    for test_name, success in results:
        status = "‚úÖ PASSED" if success else "‚ùå FAILED"
        print(f"   {test_name}: {status}")
    
    print(f"\nüìä Overall: {passed}/{total} tests passed")
    
    if passed == total:
        print("\nüéâ ALL STATE MACHINE TESTS PASSED!")
        print("üéØ State machine is ready for integration!")
    else:
        print(f"\n‚ö†Ô∏è {total - passed} tests failed. Review issues before integration.")
    
    print("=" * 60)
    
    return passed == total

if __name__ == "__main__":
    main()
